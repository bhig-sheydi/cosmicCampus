import { serve } from "https://deno.land/std@0.203.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";
import { crypto } from "https://deno.land/std@0.203.0/crypto/mod.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "content-type",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
};

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  if (req.method !== "POST") {
    return new Response("Method Not Allowed", { status: 405 });
  }

  const PAYSTACK_SECRET_KEY = Deno.env.get("PAYSTACK_SECRET_KEY");
  const PROJECT_URL = Deno.env.get("PROJECT_URL");
  const SERVICE_ROLE_KEY = Deno.env.get("SERVICE_ROLE_KEY");

  if (!PAYSTACK_SECRET_KEY || !PROJECT_URL || !SERVICE_ROLE_KEY) {
    return new Response("Server misconfigured", { status: 500 });
  }

  // ðŸ” Paystack signature verification
  const signature = req.headers.get("x-paystack-signature");
  const rawBody = await req.text();

  if (!signature) {
    return new Response("Missing Paystack signature", { status: 401 });
  }

  const hash = await crypto.subtle.sign(
    "HMAC",
    await crypto.subtle.importKey(
      "raw",
      new TextEncoder().encode(PAYSTACK_SECRET_KEY),
      { name: "HMAC", hash: "SHA-512" },
      false,
      ["sign"]
    ),
    new TextEncoder().encode(rawBody)
  );

  const computedSignature = Array.from(new Uint8Array(hash))
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");

  if (computedSignature !== signature) {
    return new Response("Invalid signature", { status: 401 });
  }

  // âœ… Signature verified â€” safe to trust payload
  const payload = JSON.parse(rawBody);

  if (payload.event !== "charge.success") {
    return new Response("Event ignored", { status: 200 });
  }

  const { reference, metadata } = payload.data;

  const checkoutSessionId = metadata?.checkout_session_id;
  const orderIds = metadata?.order_ids;

  if (!checkoutSessionId || !Array.isArray(orderIds)) {
    return new Response("Invalid metadata", { status: 400 });
  }

  const supabase = createClient(PROJECT_URL, SERVICE_ROLE_KEY, {
    auth: { persistSession: false },
  });

  // âœ… Update checkout session
  await supabase
    .from("checkout_sessions")
    .update({
      status: "paid",
      paid_at: new Date().toISOString(),
    })
    .eq("id", checkoutSessionId);

  // âœ… Update orders
  await supabase
    .from("orders")
    .update({
      status: "paid",
      paid_at: new Date().toISOString(),
    })
    .in("id", orderIds);

  return new Response(
    JSON.stringify({ success: true }),
    { status: 200, headers: corsHeaders }
  );
});
